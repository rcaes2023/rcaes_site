{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Research Computing","text":"<p>Fall 2023 | 16:107:606 Special Topics in Atmospheric Sciences</p> <p>Research Computing in Atmospheric and Environmental Sciences</p> <p>Rutgers University, Department of Environmental Sciences</p>"},{"location":"Final_Project/","title":"Final Project","text":""},{"location":"Final_Project/#part-i-individual-project-20","title":"Part I: Individual Project (20%)","text":"<p>The goal of the final project is to assess your ability to combine and apply the skills you have learned in class in the context of a real-world research problem. Our class has mostly focused on tools for data analysis and visualization, so this must be the focus of your final project. Specifically, we seek to assess your ability to do the following tasks: \u2022   Discover and download real datasets in standard formats (e.g. CSV, netCDF) \u2022   Load the data into pandas or xarray, performing any necessary data cleanup (dealing with missing values, proper time encoding, etc.) along the way. \u2022   Perform realistic scientific calculation involving, for example tasks such as grouping, aggregating, and applying mathematical formulas. \u2022   Visualize your results in well-formatted plots.</p>"},{"location":"Final_Project/#part-ii-reproducing-another-students-project-10","title":"Part II: Reproducing Another Student\u2019s Project (10%)","text":"<p>The goal of the second part is to assess the reproducibility of the student\u2019s project, and whether the students can reproduce and collaborate with others on code development. Our class focuses on conducting open-source research that are transparent, accessible, reproducible and inclusive, so your final project should demonstrate your understanding and ability to perform open-source research. We seek to assess your ability to: \u2022   Clearly document your analysis to make it reproducible. \u2022   Reproduce the other student\u2019s final project. \u2022   Bonus points will be given if the students submit pull requests and issues for code development. </p>"},{"location":"Schedule/","title":"Schedule","text":""},{"location":"Schedule/#schedule","title":"Schedule","text":"date topic Assignment September 11 Course introduction September 18 Overview of Jupyter Notebook, Intro to Unix, Intro to Git, Core Python Language Amarel Account September 25 Core Python Language, Loops, Functions, Classes Assignment 1 due October 2 Basic Python: Numpy and Matplotlib Assignment 2 due October 9 Guest lecture: Introduction to Amarel Assignment 3 due October 16 Python for Tabular Data: Basic Pandas Final Project Topic Due October 23 Python for Tabular Data: Numerical Analysis Assignment 4 Due October 30 Python for Multidimensional Data: Xarray Assignment 5 Due November 6 Making Maps: Cartopy, GeoViews   Assignment 7 Assignment 6 Due November 13 Environmental Sciences Packages: GeoPandas, Re-gridding tools Assignment 7 Due November 20 Reproducible Research: Python Packaging, Binder, OpenDAP Assignment 8 Due November 27 Big Data: Parallel Computing, Dask No Assignment December 4 Big Data: Cloud Computing Final Project Part I Due December 11 No Class Final Project Part II Due"},{"location":"Syllabus/","title":"Syllabus","text":""},{"location":"Syllabus/#part-1-course-information","title":"Part 1: Course Information","text":"<p>Class Time: Monday, 2 to 5 PM  Location: ENR 323</p>"},{"location":"Syllabus/#instructor","title":"Instructor:","text":"<p>Xiaomeng Jin Department of Environmental Sciences Office: ENR 230 Email: xiaomeng.jin@rutgers.edu Office Hour:: Friday, 1 \u2013 2 PM</p>"},{"location":"Syllabus/#part-2-overview","title":"Part 2: Overview","text":"<p>This course will introduce modern computing software, programming tools and best practices for open-source research that are transparent, accessible, reproducible and inclusive.   The course consists of three components:   (1) Introduction to programming in the open-source Python language and in-depth exploration of the numerical analysis and visualization packages that comprise the modern scientific Python ecosystem;  (2) Introduction to the concept of open science and best practices for conducting open-source research;   (3) Introduction to cloud and parallel computing for big data analysis. The course is designed to be accessible for graduate students in atmospheric science, environmental sciences or other disciplines in earth sciences. Student learning will be facilitated through a combination of lectures, in-class exercises, homework assignments and class projects.</p>"},{"location":"Syllabus/#part-3-course-structure","title":"Part 3: Course Structure","text":"<p>Format: The instructor will present new materials in the first half of the lecture. The second half of the class will be flipped: students will work first in small groups and then individually on assignments.  Textbook: There is no required textbook. All materials will come from free online resources and the course website itself.  Computers: Students can either bring their laptops or use the computers in ENR 323. Students will use Amarel, the university\u2019s high performance computing cluster, to work on their assignments and final project.  </p>"},{"location":"Syllabus/#part-4-grading-policy","title":"Part 4: Grading Policy","text":""},{"location":"Syllabus/#weekly-assignments-70","title":"Weekly Assignments (70%):","text":"<p>\u2022   Total: 100 \u2022   All questions complete: 50 \u2022   All questions correct: 30  \u2022   Clean, elegant, efficient code: rate between 0 and 10  \u2022   Clear comments and explanations: rate between 0 and 10  \u2022   Late penalty: -20 per day (24 hrs) \u2022   Lowest grade on an assignment will be dropped. </p>"},{"location":"Syllabus/#final-project-30","title":"Final Project (30%):","text":"<p> Part I: Individual Project (20%)  The goal of the final project is to assess your ability to combine and apply the skills you have learned in class in the context of a real-world research problem. Our class has mostly focused on tools for data analysis and visualization, so this must be the focus of your final project. Specifically, we seek to assess your ability to do the following tasks:  \u2022   Discover and download real datasets in standard formats (e.g. CSV, netCDF)  \u2022   Load the data into pandas or xarray, performing any necessary data cleanup (dealing with missing values, proper time encoding, etc.) along the way.  \u2022   Perform realistic scientific calculation involving, for example tasks such as grouping, aggregating, and applying mathematical formulas.  \u2022   Visualize your results in well-formatted plots. </p> <p> Part II: Reproducing Another Student\u2019s Project (10%)   The goal of the second part is to assess the reproducibility of the student\u2019s project, and whether the students can reproduce and collaborate with others on code development. Our class focuses on conducting open-source research that are transparent, accessible, reproducible and inclusive, so your final project should demonstrate your understanding and ability to perform open-source research. We seek to assess your ability to:  \u2022   Clearly document your analysis to make it reproducible.  \u2022   Reproduce the other student\u2019s final project.  \u2022   Bonus points will be given if the students submit pull requests and issues for code development. </p>"},{"location":"intro_to_python/","title":"Core Python Language","text":"In\u00a0[2]: Copied! <pre># comments are anything that comes after the \"#\" symbol\na = 1       # assign 1 to variable a\nb = \"hello\" # assign \"hello\" to variable b\n</pre> # comments are anything that comes after the \"#\" symbol a = 1       # assign 1 to variable a b = \"hello\" # assign \"hello\" to variable b <p>The following identifiers are used as reserved words, or keywords of the language, and cannot be used as ordinary identifiers. They must be spelled exactly as written here:</p> <pre><code>False      class      finally    is         return\nNone       continue   for        lambda     try\nTrue       def        from       nonlocal   while\nand        del        global     not        with\nas         elif       if         or         yield\nassert     else       import     pass\nbreak      except     in         raise</code></pre> <p>Additionally, the following a built in functions which are always available in your namespace once you open a python interpreter</p> <pre><code>abs() dict() help() min() setattr() all() dir() hex() next() slice() any()\ndivmod() id() object() sorted() ascii() enumerate() input() oct() staticmethod()\nbin() eval() int() open() str() bool() exec() isinstance() ord() sum() bytearray()\nfilter() issubclass() pow() super() bytes() float() iter() print() tuple()\ncallable() format() len() property() type() chr() frozenset() list() range()\nvars() classmethod() getattr() locals() repr() zip() compile() globals() map()\nreversed() __import__() complex() hasattr() max() round() delattr() hash()\nmemoryview() set()</code></pre> In\u00a0[3]: Copied! <pre># how to we see our variables?\nprint(a)\nprint(b)\nprint(a,b)\n</pre> # how to we see our variables? print(a) print(b) print(a,b) <pre>1\nhello\n1 hello\n</pre> <p>All variables are objects. Every object has a type (class). To find out what type your variables are</p> In\u00a0[4]: Copied! <pre>print(type(a))\nprint(type(b))\n</pre> print(type(a)) print(type(b)) <pre>&lt;class 'int'&gt;\n&lt;class 'str'&gt;\n</pre> In\u00a0[5]: Copied! <pre># as a shortcut, iPython notebooks will automatically print whatever is on the last line\ntype(b)\n</pre> # as a shortcut, iPython notebooks will automatically print whatever is on the last line type(b) Out[5]: <pre>str</pre> In\u00a0[6]: Copied! <pre># we can check for the type of an object\nprint(type(a) is int)\nprint(type(a) is str)\n</pre> # we can check for the type of an object print(type(a) is int) print(type(a) is str) <pre>True\nFalse\n</pre> <p>Different objects attributes and methods, which can be accessed via the syntax <code>variable.method</code></p> <p>IPython will autocomplete if you press <code>&lt;tab&gt;</code> to show you the methods available.</p> In\u00a0[7]: Copied! <pre># this returns the method itself\nb.capitalize\n</pre> # this returns the method itself b.capitalize Out[7]: <pre>&lt;function str.capitalize&gt;</pre> In\u00a0[8]: Copied! <pre># this calls the method\nb.capitalize()\n# there are lots of other methods\n</pre> # this calls the method b.capitalize() # there are lots of other methods Out[8]: <pre>'Hello'</pre> In\u00a0[9]: Copied! <pre># binary operations act differently on different types of objects\nc = 'World'\nprint(b + c)\nprint(a + 2)\nprint(a + b)\n</pre> # binary operations act differently on different types of objects c = 'World' print(b + c) print(a + 2) print(a + b) <pre>helloWorld\n3\n</pre> <pre>\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\n&lt;ipython-input-9-d0ea84c04eb4&gt; in &lt;module&gt;()\n      3 print(b + c)\n      4 print(a + 2)\n----&gt; 5 print(a + b)\n\nTypeError: unsupported operand type(s) for +: 'int' and 'str'</pre> In\u00a0[10]: Copied! <pre># addition / subtraction\n1+1-5\n</pre> # addition / subtraction 1+1-5 Out[10]: <pre>-3</pre> In\u00a0[11]: Copied! <pre># multiplication\n5 * 10\n</pre> # multiplication 5 * 10 Out[11]: <pre>50</pre> In\u00a0[12]: Copied! <pre># division\n1/2\n</pre> # division 1/2 Out[12]: <pre>0.5</pre> In\u00a0[13]: Copied! <pre># that was automatically converted to a float\ntype(1/2)\n</pre> # that was automatically converted to a float type(1/2) Out[13]: <pre>float</pre> In\u00a0[14]: Copied! <pre># exponentiation\n2**4\n</pre> # exponentiation 2**4 Out[14]: <pre>16</pre> In\u00a0[15]: Copied! <pre># rounding\nround(9/10)\n</pre> # rounding round(9/10) Out[15]: <pre>1</pre> In\u00a0[16]: Copied! <pre># built in complex number support\n(1+2j) / (3-4j)\n</pre> # built in complex number support (1+2j) / (3-4j) Out[16]: <pre>(-0.2+0.4j)</pre> In\u00a0[17]: Copied! <pre># logic\nTrue and True\n</pre> # logic True and True Out[17]: <pre>True</pre> In\u00a0[18]: Copied! <pre>True and False\n</pre> True and False Out[18]: <pre>False</pre> In\u00a0[19]: Copied! <pre>True or True\n</pre> True or True Out[19]: <pre>True</pre> In\u00a0[20]: Copied! <pre>(not True) or (not False)\n</pre> (not True) or (not False) Out[20]: <pre>True</pre> In\u00a0[21]: Copied! <pre>x = 100\nif x &gt; 0:\n    print('Positive Number')\nelif x &lt; 0:\n    print('Negative Number')\nelse:\n    print ('Zero!')\n</pre> x = 100 if x &gt; 0:     print('Positive Number') elif x &lt; 0:     print('Negative Number') else:     print ('Zero!') <pre>Positive Number\n</pre> In\u00a0[22]: Copied! <pre># indentation is MANDATORY\n# blocks are closed by indentation level\nif x &gt; 0:\n    print('Positive Number')\n    if x &gt;= 100:\n        print('Huge number!')\n</pre> # indentation is MANDATORY # blocks are closed by indentation level if x &gt; 0:     print('Positive Number')     if x &gt;= 100:         print('Huge number!') <pre>Positive Number\nHuge number!\n</pre> In\u00a0[26]: Copied! <pre># make a loop \ncount = 0\nwhile count &lt; 10:\n    # bad way\n    # count = count + 1\n    # better way\n    count += 1\nprint(count)\n</pre> # make a loop  count = 0 while count &lt; 10:     # bad way     # count = count + 1     # better way     count += 1 print(count) <pre>10\n</pre> In\u00a0[29]: Copied! <pre># use range\nfor i in range(5):\n    print(i)\n</pre> # use range for i in range(5):     print(i) <pre>0\n1\n2\n3\n4\n</pre> <p>Important point: in python, we always count from 0!</p> In\u00a0[30]: Copied! <pre># what is range?\ntype(range)\n</pre> # what is range? type(range) Out[30]: <pre>type</pre> In\u00a0[33]: Copied! <pre>range?\n</pre> range? In\u00a0[37]: Copied! <pre># iterate over a list we make up\nfor pet in ['dog', 'cat', 'fish']:\n    print(pet, len(pet))\n</pre> # iterate over a list we make up for pet in ['dog', 'cat', 'fish']:     print(pet, len(pet)) <pre>dog 3\ncat 3\nfish 4\n</pre> <p>What is the thing in brackets? A list! Lists are one of the core python data structures.</p> In\u00a0[64]: Copied! <pre>l = ['dog', 'cat', 'fish']\ntype(l)\n</pre> l = ['dog', 'cat', 'fish'] type(l) Out[64]: <pre>list</pre> In\u00a0[39]: Copied! <pre># list have lots of methods\nl.sort()\nl\n</pre> # list have lots of methods l.sort() l Out[39]: <pre>['cat', 'dog', 'fish']</pre> In\u00a0[46]: Copied! <pre># we can convert a range to a list\nr = list(range(5))\nr\n</pre> # we can convert a range to a list r = list(range(5)) r Out[46]: <pre>[0, 1, 2, 3, 4]</pre> In\u00a0[47]: Copied! <pre>while r:\n    p = r.pop()\n    print('p:', p)\n    print('r:', r)\n</pre> while r:     p = r.pop()     print('p:', p)     print('r:', r) <pre>p: 4\nr: [0, 1, 2, 3]\np: 3\nr: [0, 1, 2]\np: 2\nr: [0, 1]\np: 1\nr: [0]\np: 0\nr: []\n</pre> <p>There are many different ways to interact with lists. Exploring them is part of the fun of python.</p> <p>list.append(x) Add an item to the end of the list. Equivalent to a[len(a):] = [x].</p> <p>list.extend(L) Extend the list by appending all the items in the given list. Equivalent to a[len(a):] = L.</p> <p>list.insert(i, x) Insert an item at a given position. The first argument is the index of the element before which to insert, so a.insert(0, x) inserts at the front of the list, and a.insert(len(a), x) is equivalent to a.append(x).</p> <p>list.remove(x) Remove the first item from the list whose value is x. It is an error if there is no such item.</p> <p>list.pop([i]) Remove the item at the given position in the list, and return it. If no index is specified, a.pop() removes and returns the last item in the list. (The square brackets around the i in the method signature denote that the parameter is optional, not that you should type square brackets at that position. You will see this notation frequently in the Python Library Reference.)</p> <p>list.clear() Remove all items from the list. Equivalent to del a[:].</p> <p>list.index(x) Return the index in the list of the first item whose value is x. It is an error if there is no such item.</p> <p>list.count(x) Return the number of times x appears in the list.</p> <p>list.sort() Sort the items of the list in place.</p> <p>list.reverse() Reverse the elements of the list in place.</p> <p>list.copy() Return a shallow copy of the list. Equivalent to a[:].</p> <p>Don't assume you know how list operations work!</p> In\u00a0[52]: Copied! <pre># \"add\" two lists\nx = list(range(5))\ny = list(range(10,15))\nz = x + y\nz\n</pre> # \"add\" two lists x = list(range(5)) y = list(range(10,15)) z = x + y z Out[52]: <pre>[0, 1, 2, 3, 4, 10, 11, 12, 13, 14]</pre> In\u00a0[55]: Copied! <pre># access items from a list\nprint('first', z[0])\nprint('last', z[-1])\nprint('first 3', z[:3])\nprint('last 3', z[-3:])\nprint('middle, skipping every other item', z[5:10:2])\n</pre> # access items from a list print('first', z[0]) print('last', z[-1]) print('first 3', z[:3]) print('last 3', z[-3:]) print('middle, skipping every other item', z[5:10:2]) <pre>first 0\nlast 14\nfirst 3 [0, 1, 2]\nlast 3 [12, 13, 14]\nmiddle, skipping every other item [10, 12, 14]\n</pre> <p>MEMORIZE THIS SYNTAX! It is central to so much of python and often proves confusing for users coming from other languages.</p> <p>In terms of set notation, python indexing is left inclusive, right exclusive. If you remember this, you will never go wrong.</p> In\u00a0[60]: Copied! <pre># that means we get an error from the following\nN = len(z)\nz[N]\n</pre> # that means we get an error from the following N = len(z) z[N] <pre>\n---------------------------------------------------------------------------\nIndexError                                Traceback (most recent call last)\n&lt;ipython-input-60-a6804f3b0ad3&gt; in &lt;module&gt;()\n      1 # that means we get an error from the following\n      2 N = len(z)\n----&gt; 3 z[N]\n\nIndexError: list index out of range</pre> In\u00a0[63]: Copied! <pre># this index notation also applies to strings\nname = 'Ryan Abernathey'\nprint(name[:4])\n</pre> # this index notation also applies to strings name = 'Ryan Abernathey' print(name[:4]) <pre>Ryan\n</pre> In\u00a0[57]: Copied! <pre># you can also test for the presence of items in a list\n5 in z\n</pre> # you can also test for the presence of items in a list 5 in z Out[57]: <pre>False</pre> <p>Lists are not meant for math! They don't have a datatype.</p> In\u00a0[58]: Copied! <pre>z[4] = 'fish'\nz\n</pre> z[4] = 'fish' z Out[58]: <pre>[0, 1, 2, 3, 'fish', 10, 11, 12, 13, 14]</pre> <p>Python is full of tricks for iterating and working with lists</p> In\u00a0[59]: Copied! <pre># a cool python trick: list comprehension\nsquares = [n**2 for n in range(5)]\nsquares\n</pre> # a cool python trick: list comprehension squares = [n**2 for n in range(5)] squares Out[59]: <pre>[0, 1, 4, 9, 16]</pre> In\u00a0[75]: Copied! <pre># iterate over two lists together uzing zip\nfor item1, item2 in zip(x,y):\n    print('first:', item1, 'second:', item2)\n</pre> # iterate over two lists together uzing zip for item1, item2 in zip(x,y):     print('first:', item1, 'second:', item2) <pre>first: 0 second: 10\nfirst: 1 second: 11\nfirst: 2 second: 12\nfirst: 3 second: 13\nfirst: 4 second: 14\n</pre> In\u00a0[69]: Copied! <pre># tuples are created with parentheses, or just commas\na = ('Ryan', 33, True)\nb = 'Takaya', 25, False\ntype(b)\n</pre> # tuples are created with parentheses, or just commas a = ('Ryan', 33, True) b = 'Takaya', 25, False type(b) Out[69]: <pre>tuple</pre> In\u00a0[70]: Copied! <pre># can be indexed like arrays\nprint(a[1]) # not the first element!\n</pre> # can be indexed like arrays print(a[1]) # not the first element! <pre>33\n</pre> In\u00a0[71]: Copied! <pre># and they can be unpacked\nname, age, status = a\n</pre> # and they can be unpacked name, age, status = a In\u00a0[76]: Copied! <pre># different ways to create dictionaries\nd = {'name': 'Ryan', 'age': 33}\ne = dict(name='Takaya', age=25)\ne\n</pre> # different ways to create dictionaries d = {'name': 'Ryan', 'age': 33} e = dict(name='Takaya', age=25) e Out[76]: <pre>{'age': 25, 'name': 'Takaya'}</pre> In\u00a0[82]: Copied! <pre># access a value\nd['name']\n</pre> # access a value d['name'] Out[82]: <pre>'Ryan'</pre> <p>Square brackets <code>[...]</code> are python for \"get item\" in many different contexts.</p> In\u00a0[79]: Copied! <pre># test for the presence of a key\nprint('age' in d)\nprint('height' in e)\n</pre> # test for the presence of a key print('age' in d) print('height' in e) <pre>True\nFalse\n</pre> In\u00a0[83]: Copied! <pre># try to access a non-existant key\nd['height']\n</pre> # try to access a non-existant key d['height'] <pre>\n---------------------------------------------------------------------------\nKeyError                                  Traceback (most recent call last)\n&lt;ipython-input-83-261ef018477b&gt; in &lt;module&gt;()\n      1 # try to access a non-existant key\n----&gt; 2 d['height']\n\nKeyError: 'height'</pre> In\u00a0[84]: Copied! <pre># add a new key\nd['height'] = (5,11) # a tuple\nd\n</pre> # add a new key d['height'] = (5,11) # a tuple d Out[84]: <pre>{'age': 33, 'height': (5, 11), 'name': 'Ryan'}</pre> In\u00a0[86]: Copied! <pre># keys don't have to be strings\nd[99] = 'ninety nine'\nd\n</pre> # keys don't have to be strings d[99] = 'ninety nine' d Out[86]: <pre>{99: 'ninety nine', 'age': 33, 'name': 'Ryan', 'height': (5, 11)}</pre> In\u00a0[87]: Copied! <pre># iterate over keys\nfor k in d:\n    print(k, d[k])\n</pre> # iterate over keys for k in d:     print(k, d[k]) <pre>99 ninety nine\nage 33\nname Ryan\nheight (5, 11)\n</pre> In\u00a0[88]: Copied! <pre># better way\n### python 2\n### for key, val in d.iteritems()\nfor key, val in d.items():\n    print(key, val)\n</pre> # better way ### python 2 ### for key, val in d.iteritems() for key, val in d.items():     print(key, val) <pre>99 ninety nine\nage 33\nname Ryan\nheight (5, 11)\n</pre>"},{"location":"intro_to_python/#core-python-language","title":"Core Python Language\u00b6","text":"<p>Mostly copied from the official python tutorial</p>"},{"location":"intro_to_python/#invoking-python","title":"Invoking Python\u00b6","text":"<p>There are three main ways to use python.</p> <ol> <li>By running a python file, e.g. <code>python myscript.py</code></li> <li>Through an interactive console (python interpreter or ipython shell)</li> <li>In an interactive iPython notebook</li> </ol> <p>We will be using the iPython notebook.</p>"},{"location":"intro_to_python/#python-versions","title":"Python Versions\u00b6","text":"<p>There are two versions of the python language out there: python 2 and python 3. Python 2 is more common in the wild but is depracated. The community is moving to python 3. As new python learners, you should learn python 3. But it is important to be aware that python 2 exists. It is possible that a package you want to use is only supported in python 2. In general, it is pretty easy to switch between then.</p> <p>Some of the main changes in python 3 are:</p> <ul> <li><code>print</code> is a function</li> <li>Integer division returns a float</li> <li>Iterators behave differently</li> <li>Unicode is used for encoding code</li> </ul>"},{"location":"intro_to_python/#basic-variables-numbers-and-string","title":"Basic Variables: Numbers and String\u00b6","text":""},{"location":"intro_to_python/#math","title":"Math\u00b6","text":"<p>Basic arithmetic and boolean logic is part of the core python library.</p>"},{"location":"intro_to_python/#conditionals","title":"Conditionals\u00b6","text":"<p>The first step to programming. Plus an intro to python syntax.</p>"},{"location":"intro_to_python/#more-flow-control","title":"More Flow Control\u00b6","text":""},{"location":"intro_to_python/#lists","title":"Lists\u00b6","text":""},{"location":"intro_to_python/#other-data-structures","title":"Other Data Structures\u00b6","text":"<p>We are almost there. We have the building blocks we need to do basic programming. But python has some other data structures we need to learn about.</p>"},{"location":"intro_to_python/#tuples","title":"Tuples\u00b6","text":"<p>Tuples are similar to lists, but they are immutable\u2014they can't be extended or modified. What is the point of this? Generally speaking: to pack together inhomogeneous data. Tuples can then be unpacked and distributed by other parts of your code.</p> <p>Tuples may seem confusing at first, but with time you will come to appreciate them.</p>"},{"location":"intro_to_python/#dictionaries","title":"Dictionaries\u00b6","text":"<p>This is an extremely useful data structure. It maps keys to values.</p> <p>Dictionaries are unordered!</p>"}]}