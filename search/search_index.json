{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Research Computing","text":"<p>Fall 2023 | 16:107:606 Special Topics in Atmospheric Sciences Research Computing in Atmospheric and Environmental Sciences Rutgers University, Department of Environmental Sciences</p> <p></p>"},{"location":"Assignment_0/","title":"Create your Accounts on Amarel and GitHub","text":""},{"location":"Assignment_0/#amarel-account","title":"Amarel Account","text":"<p>https://oarc.rutgers.edu/amarel-cluster-access-request/</p>"},{"location":"Assignment_0/#github-account","title":"GitHub Account","text":"<p>https://github.com  Student Account: https://education.github.com/benefits?type=student</p>"},{"location":"Final_Project/","title":"Final Project","text":""},{"location":"Final_Project/#part-i-individual-project-20","title":"Part I: Individual Project (20%)","text":"<p>The goal of the final project is to assess your ability to combine and apply the skills you have learned in class in the context of a real-world research problem. Our class has mostly focused on tools for data analysis and visualization, so this must be the focus of your final project. Specifically, we seek to assess your ability to do the following tasks: \u2022   Discover and download real datasets in standard formats (e.g. CSV, netCDF) \u2022   Load the data into pandas or xarray, performing any necessary data cleanup (dealing with missing values, proper time encoding, etc.) along the way. \u2022   Perform realistic scientific calculation involving, for example tasks such as grouping, aggregating, and applying mathematical formulas. \u2022   Visualize your results in well-formatted plots.</p>"},{"location":"Final_Project/#part-ii-reproducing-another-students-project-10","title":"Part II: Reproducing Another Student\u2019s Project (10%)","text":"<p>The goal of the second part is to assess the reproducibility of the student\u2019s project, and whether the students can reproduce and collaborate with others on code development. Our class focuses on conducting open-source research that are transparent, accessible, reproducible and inclusive, so your final project should demonstrate your understanding and ability to perform open-source research. We seek to assess your ability to: \u2022   Clearly document your analysis to make it reproducible. \u2022   Reproduce the other student\u2019s final project. \u2022   Bonus points will be given if the students submit pull requests and issues for code development. </p>"},{"location":"Lecture_2_intro_to_unix/","title":"Intro to Unix","text":"<p>The notes below are modified from the excellent Unix Shell tutorial  that is freely available on the Software Carpentry website. I highly recommend checking out the full version for further reading. The material is being used here under the terms of the Creative Commons Attribution license.</p>"},{"location":"Lecture_2_intro_to_unix/#what-is-unix-shell","title":"What is Unix shell?","text":"<p>The Unix shell is both a command-line interface and a scripting language. With the shell, it is possible to invoke complicated programs like climate modeling or a simple command that create an empty directory.  The most popular Unix Shell is Bash. </p>"},{"location":"Lecture_2_intro_to_unix/#navigating-files-and-directories","title":"Navigating Files and Directories","text":"<p>Several commands are frequently used to create, inspect, rename, and delete files and directories.</p> <p>To get started, open a terminal using the OpenOnDemand Clusters: Amarel Cluster Shell Access. After entering your password, you will see the welcome message. </p> <pre><code>(base) [xj103@amarel2 ~]$ \n</code></pre> <p>The dollar sign is a prompt, which shows us that the shell is waiting for input.</p> <p><code>xj103</code> is our username and <code>amarel2</code> is the hostname. The username will be your NetID. The hostname indicates the node you're at. Here we are using login nodes (amarel1, amarel2, etc.). Cluster login nodes provide a shared environment where users can transfer data, build software, and prepare their calculations.  Running applications on a shared login node or doing things that consume significant compute, memory, or network resources can unfairly impact other users.  Please do not do that. Do not run your research applications on the login node.  If you log into the terminal via a compute nodes, you will see the hostname as hal0001, hal0002 etc., which are nodes assigned to you for computation. </p> <p>From now on, we will just use a <code>$</code> to indicate the prompt.</p> <p>To find out your username in general, you can use the command</p> <pre><code>$ whoami\nxj103\n</code></pre> <p>and to find out your hostname</p> <pre><code>$ hostname\namarel2.amarel.rutgers.edu\n</code></pre> <p>Next, let's find out where we are by running a command called <code>pwd</code> (which stands for \"print working directory\"). At any moment, our current working directory is our current default directory, i.e., the directory that the computer assumes we want to run commands in unless we explicitly specify something else. Here, the computer's response is <code>/home/xj103</code>, which is the home directory of the user named <code>xj103</code>.</p> <pre><code>$ pwd\n</code></pre> <pre><code>/home/xj103\n</code></pre> <p>To understand what a \"home directory\" is, let's have a look at how the file system as a whole is organized.  For the sake of this example, we'll be illustrating the filesystem on Amarel.  </p> <pre><code>$ cd /\n</code></pre> <p>Now let's learn the command that will let us see the contents of our own filesystem.  We can see what's in our home directory by running <code>ls</code>, which stands for \"listing\":</p> <pre><code>$ ls\n</code></pre> <p>On a Unix computer, at the top is the root directory that holds everything else. We refer to it using a slash character <code>/</code> on its own; this is the leading slash in <code>/home/xj103</code>.</p> <p>Inside that directory are several other directories: <code>bin</code> (which is where some built-in programs are stored), <code>lib</code> (for the software \"libraries\" used by different programs), <code>home</code> (where users' personal directories are located), <code>projects</code> (where project data are stored), <code>etc</code> (system-wide configuration files), and so on.  </p> <p>Now let's go back to our home directory with ~ (tilde)</p> <pre><code>$ cd ~\n</code></pre> <p><code>ls</code> prints the names of the files and directories in the current directory in alphabetical order, arranged neatly into columns. We can make its output more comprehensible by using the flag <code>-F</code>, which tells <code>ls</code> to add a trailing <code>/</code> to the names of directories:</p> <pre><code>$ ls -F\n</code></pre> <p><code>ls</code> has lots of other options. To find out what they are, we can type:</p> <pre><code>$ man ls\n</code></pre> <p><code>man</code> is the Unix \"manual\" command: it prints a description of a command and its options, and (if you're lucky) provides a few examples of how to use it. To navigate through the <code>man</code> pages, you may use the up and down arrow keys to move line-by-line. Quit the <code>man</code> pages by typing \"q\".</p> <p>The command to change locations is <code>cd</code> followed by a directory name to change our working directory. <code>cd</code> stands for \"change directory\", which is a bit misleading: the command doesn't change the directory, it changes the shell's idea of what directory we are in.</p> <p>Let's say we want to move to the <code>Documents</code> directory we saw above.  We can use the following series of commands to get there:</p> <pre><code>$ cd Documents\n</code></pre> <p>These commands will move us from our home directory onto into the <code>Documents</code> directory. <code>cd</code> doesn't print anything, but if we run <code>pwd</code> after it, we can see that we are now in <code>/home/xj103/Documents</code>.</p> <p>We now know how to go down the directory tree, but how do we go up? There is a shortcut in the shell to move up one directory level that looks like this:</p> <pre><code>$ cd ..\n</code></pre> <p><code>..</code> is a special directory name meaning \"the directory containing this one\", or more succinctly, the parent of the current directory. Sure enough, if we run <code>pwd</code> after running <code>cd ..</code>, we're back in <code>/home/xj103</code>:</p> <pre><code>$ pwd\n</code></pre> <pre><code>/home/xj103\n</code></pre> <p>The special directory <code>..</code> doesn't usually show up when we run <code>ls</code>.  If we want to display it, we can give <code>ls</code> the <code>-a</code> flag:</p> <pre><code>$ ls -F -a\n</code></pre> <p><code>-a</code> stands for \"show all\"; it forces <code>ls</code> to show us file and directory names that begin with <code>.</code>, such as <code>..</code> (which, if we're in <code>/home/xj103/Documents</code>, refers to the <code>/home/xj103</code> directory) As you can see, it also displays another special directory that's just called <code>.</code>, which means \"the current working directory\". It may seem redundant to have a name for it, but we'll see some uses for it soon.</p> <p>Note that in most command line tools, multiple parameters can be combined with a single <code>-</code> and no spaces between the parameters: <code>ls -F -a</code> is equivalent to <code>ls -Fa</code>.</p> <p>These then, are the basic commands for navigating the filesystem on your computer: <code>pwd</code>, <code>ls</code> and <code>cd</code>.  Let's explore some variations on those commands.  What happens if you type <code>cd</code> on its own, without giving a directory?  </p> <pre><code>$ cd\n</code></pre> <p>How can you check what happened?  <code>pwd</code> gives us the answer!  </p> <pre><code>$ pwd\n</code></pre> <pre><code>/home/xj103\n</code></pre> <p>It turns out that <code>cd</code> without an argument will return you to your home directory, which is great if you've gotten lost in your own filesystem.  </p> <pre><code>$ cd \n</code></pre> <p>Check that we've moved to the right place by running <code>pwd</code> and <code>ls -F</code> </p> <p>If we want to move up one level from the data directory, we could use <code>cd ..</code>.  But there is another way to move to any directory, regardless of your current location.  </p> <p>So far, when specifying directory names, or even a directory path (as above), we have been using relative paths.  When you use a relative path with a command like <code>ls</code> or <code>cd</code>, it tries to find that location from where we are, rather than from the root of the file system.  </p> <p>However, it is possible to specify the absolute path to a directory by including its entire path from the root directory, which is indicated by a leading slash.  The leading <code>/</code> tells the computer to follow the path from the root of the file system, so it always refers to exactly one directory, no matter where we are when we run the command.</p> <p>This allows us to move to our <code>examples</code> directory from anywhere on the filesystem.  To find the absolute path we're looking for, we can use <code>pwd</code> and then extract the piece we need to move to <code>examples</code>.  </p> <pre><code>$ pwd\n</code></pre> <pre><code>$ cd /home/xj103/Documents/\n</code></pre> <p>Run <code>pwd</code> and <code>ls -F</code> to ensure that we're in the directory we expect.  </p>"},{"location":"Lecture_2_intro_to_unix/#two-more-shortcuts","title":"Two More Shortcuts","text":"<p>The shell interprets the character <code>~</code> (tilde) at the start of a path to mean \"the current user's home directory\". For example, if my home directory is <code>/home/xj103</code>, then <code>~/rcaes</code> is equivalent to <code>/home/xj103/rcaes</code>. This only works if it is the first character in the path.</p> <p>Another shortcut is the <code>-</code> (dash) character.  <code>cd</code> will translate <code>-</code> into the previous directory I was in, which is faster than having to remember, then type, the full path.  This is a very efficient way of moving back and forth between directories. The difference between <code>cd ..</code> and <code>cd -</code> is that the former brings you up, while the latter brings you back. You can think of it as the Last Channel button on a TV remote.</p>"},{"location":"Lecture_2_intro_to_unix/#tab-completion","title":"Tab Completion","text":"<p>Typing the full path to directories and files can be slow and annoying. Fortunately, we have \"tab completion\" to help us. Try typing <code>cd Doc</code> and then press the <code>&lt;tab&gt;</code>. The system will try to \"auto complete\" your command. Pressing tab twice brings up a list of all the files, and so on. This is called tab completion, and we will see it in many other tools as we go on.</p>"},{"location":"Lecture_2_intro_to_unix/#key-points","title":"Key Points:","text":"<ul> <li>\"The file system is responsible for managing information on the disk.\"</li> <li>\"Information is stored in files, which are stored in directories (folders).\"</li> <li>\"Directories can also store other directories, which forms a directory tree.\"</li> <li>\"<code>cd path</code> changes the current working directory.\"</li> <li>\"<code>ls path</code> prints a listing of a specific file or directory; <code>ls</code> on its own lists the current working directory.\"</li> <li><code>pwd</code> prints the user's current working directory.</li> <li><code>whoami</code> shows the user's current identity.</li> <li><code>/</code> on its own is the root directory of the whole file system.</li> <li>A relative path specifies a location starting from the current location.</li> <li>An absolute path specifies a location from the root of the file system.</li> <li>Directory names in a path are separated with '/' (forward slash) on Unix, but '\\\\' (backslash) on Windows.</li> <li>'..' means 'the directory above the current one'; '.' on its own means 'the current directory'.</li> <li>Most files' names are <code>something.extension</code>. The extension isn't required, and doesn't guarantee anything, but is normally used to indicate the type of data in the file.</li> <li>Most commands take options (flags) which begin with a '-'.</li> </ul>"},{"location":"Lecture_2_intro_to_unix/#working-with-files-and-directories","title":"Working with Files and Directories","text":"<p>We now know how to explore files and directories, but how do we create them in the first place? Let's go back to our home directory and use <code>ls -F</code> to see what it contains:</p> <pre><code>$ cd\n$ pwd\n</code></pre> <pre><code>/home/xj103/\n</code></pre> <p>Let's create a new directory called <code>thesis</code> using the command <code>mkdir thesis</code> (which has no output):</p> <pre><code>$ mkdir thesis\n</code></pre> <p>As you might guess from its name, <code>mkdir</code> means \"make directory\". Since <code>thesis</code> is a relative path (i.e., doesn't have a leading slash), the new directory is created in the current working directory:</p> <pre><code>$ ls -F\n</code></pre>"},{"location":"Lecture_2_intro_to_unix/#good-names-for-files-and-directories","title":"Good names for files and directories","text":"<p>Complicated names of files and directories can make your life painful  when working on the command line. Here we provide a few useful  tips for the names of your files.</p> <ol> <li> <p>Don't use whitespaces.</p> <p>Whitespaces can make a name more meaningful    but since whitespace is used to break arguments on the command line    is better to avoid them on name of files and directories. You can use <code>-</code> (dash) and <code>_</code> (underscore) instead of whitespace.</p> </li> <li> <p>Don't begin the name with <code>-</code> (dash).</p> <p>Commands treat names starting with <code>-</code> as options.</p> </li> <li> <p>Stick with letters, numbers, <code>.</code> (period), <code>-</code> (dash) and <code>_</code> (underscore).</p> <p>Many other characters have special meanings on the command line. We will learn about some of these during this lesson. There are special characters that can cause your command to not work as expected and can even result in data loss.</p> </li> </ol> <p>If you need to refer to names of files or directories that have whitespace  or another non-alphanumeric character, you should surround the name in quotes (<code>\"\"</code>).</p> <p>Since we've just created the <code>thesis</code> directory, there's nothing in it yet:</p> <pre><code>$ ls -F thesis\n</code></pre> <p>Let's change our working directory to <code>thesis</code> using <code>cd</code>. We then create a blank new file called <code>draft.txt</code> using the <code>touch command</code>:</p> <pre><code>$ cd thesis\n$ touch draft.txt\n</code></pre> <p>Now we can edit the file in JupyterLab's text editor. Let's type in a few lines of text. Once we're happy with our text, we save the file, and return to the shell.</p> <p><code>ls</code> now shows that we have created a file called <code>draft.txt</code>:</p> <pre><code>$ ls\ndraft.txt\n</code></pre> <p>Let's tidy up by running <code>rm draft.txt</code>:</p> <pre><code>$ rm draft.txt\n</code></pre> <p>This command removes files (<code>rm</code> is short for \"remove\"). If we run <code>ls</code> again, its output is empty once more, which tells us that our file is gone:</p> <pre><code>$ ls\n</code></pre>"},{"location":"Lecture_2_intro_to_unix/#deleting-is-forever","title":"Deleting Is Forever","text":"<p>The Unix shell doesn't have a trash bin that we can recover deleted files from (though most graphical interfaces to Unix do).  Instead, when we delete files, they are unhooked from the file system so that their storage space on disk can be recycled. Tools for finding and recovering deleted files do exist, but there's no guarantee they'll work in any particular situation, since the computer may recycle the file's disk space right away.</p> <p>Let's re-create that file and then move up one directory to <code>/home/xj103</code> using <code>cd ..</code>:</p> <pre><code>$ touch draft.txt\n$ cd ..\n</code></pre> <p>If we try to remove the entire <code>thesis</code> directory using <code>rm thesis</code>, we get an error message:</p> <pre><code>$ rm thesis\n</code></pre> <pre><code>rm: cannot remove `thesis`: Is a directory\n</code></pre> <p>This happens because <code>rm</code> by default only works on files, not directories.</p> <p>To really get rid of <code>thesis</code> we must also delete the file <code>draft.txt</code>. We can do this with the recursive option for <code>rm</code>:</p> <pre><code>$ rm -r thesis\n</code></pre>"},{"location":"Lecture_2_intro_to_unix/#with-great-power-comes-great-responsibility","title":"With Great Power Comes Great Responsibility","text":"<p>Removing the files in a directory recursively can be very dangerous  operation. If we're concerned about what we might be deleting we can  add the \"interactive\" flag <code>-i</code> to <code>rm</code> which will ask us for confirmation  before each step</p> <pre><code> $ rm -r -i thesis\n rm: descend into directory \u2018thesis\u2019? y\n rm: remove regular file \u2018thesis/draft.txt\u2019? y\n rm: remove directory \u2018thesis\u2019? y\n</code></pre> <p>This removes everything in the directory, then the directory itself, asking  at each step for you to confirm the deletion.</p> <p>Let's create that directory and file one more time.</p> <pre><code>$ mkdir thesis\n$ touch thesis/draft.txt\n$ ls thesis\n</code></pre> <pre><code>draft.txt\n</code></pre> <p><code>draft.txt</code> isn't a particularly informative name, so let's change the file's name using <code>mv</code>, which is short for \"move\":</p> <pre><code>$ mv thesis/draft.txt thesis/quotes.txt\n</code></pre> <p>The first parameter tells <code>mv</code> what we're \"moving\", while the second is where it's to go. In this case, we're moving <code>thesis/draft.txt</code> to <code>thesis/quotes.txt</code>, which has the same effect as renaming the file. Sure enough, <code>ls</code> shows us that <code>thesis</code> now contains one file called <code>quotes.txt</code>:</p> <pre><code>$ ls thesis\n</code></pre> <pre><code>quotes.txt\n</code></pre> <p>One has to be careful when specifying the target file name, since <code>mv</code> will silently overwrite any existing file with the same name, which could lead to data loss. An additional flag, <code>mv -i</code> (or <code>mv --interactive</code>), can be used to make <code>mv</code> ask you for confirmation before overwriting.</p> <p>Just for the sake of consistency, <code>mv</code> also works on directories</p> <p>Let's move <code>quotes.txt</code> into the current working directory. We use <code>mv</code> once again, but this time we'll just use the name of a directory as the second parameter to tell <code>mv</code> that we want to keep the filename, but put the file somewhere new. (This is why the command is called \"move\".) In this case, the directory name we use is the special directory name <code>.</code> that we mentioned earlier.</p> <pre><code>$ mv thesis/quotes.txt .\n</code></pre> <p>The effect is to move the file from the directory it was in to the current working directory. <code>ls</code> now shows us that <code>thesis</code> is empty:</p> <pre><code>$ ls thesis\n</code></pre> <p>Further, <code>ls</code> with a filename or directory name as a parameter only lists that file or directory. We can use this to see that <code>quotes.txt</code> is still in our current directory:</p> <pre><code>$ ls quotes.txt\n</code></pre> <pre><code>quotes.txt\n</code></pre> <p>The <code>cp</code> command works very much like <code>mv</code>, except it copies a file instead of moving it. We can check that it did the right thing using <code>ls</code> with two paths as parameters --- like most Unix commands, <code>ls</code> can be given multiple paths at once:</p> <pre><code>$ cp quotes.txt thesis/quotations.txt\n$ ls \n</code></pre> <pre><code>quotes.txt   thesis/quotations.txt\n</code></pre> <p>To prove that we made a copy, let's delete the <code>quotes.txt</code> file in the current directory and then run that same <code>ls</code> again.</p> <pre><code>$ rm quotes.txt\n$ ls quotes.txt thesis/quotations.txt\n</code></pre> <pre><code>ls: cannot access quotes.txt: No such file or directory\nthesis/quotations.txt\n</code></pre> <p>This time it tells us that it can't find <code>quotes.txt</code> in the current directory, but it does find the copy in <code>thesis</code> that we didn't delete.</p>"},{"location":"Lecture_2_intro_to_unix/#key-points_1","title":"Key Points","text":"<ul> <li><code>cp old new</code> copies a file.</li> <li><code>mkdir path</code> creates a new directory.</li> <li><code>mv old new</code> moves (renames) a file or directory.</li> <li><code>rm path</code> removes (deletes) a file.</li> <li>Use of the Control key may be described in many ways, including <code>Ctrl-X</code>, <code>Control-X</code>, and <code>^X</code>.</li> <li>The shell does not have a trash bin: once something is deleted, it's really gone.</li> <li>Depending on the type of work you do, you may need a more powerful text editor than Nano.</li> </ul>"},{"location":"Lecture_2_intro_to_unix/#learning-more","title":"Learning More","text":"<p>The goal of this lesson was to familiarize you with the basics of working with files and directories. There is a lot more to the unix shell and filexsystem than what we have  covered here! To ge deeper with self study, we recommend the excellent Software Carpentry Unix Shell Lesson, on which the above material was based.</p>"},{"location":"Schedule/","title":"Schedule","text":""},{"location":"Schedule/#schedule","title":"Schedule","text":"date topic Assignment Sept 11 Course introduction Sept 18 Overview of Jupyter Notebook, Intro to Unix, Intro to Git, Python Environment Amarel &amp; GitHub Account Sept 25 Core Python Language, Loops, Functions, Classes Assignment 1 due Oct 2 Basic Python: Numpy and Matplotlib Assignment 2 due Oct 9 Guest lecture: Introduction to Amarel Assignment 3 due Oct 16 Python for Tabular Data: Basic Pandas Final Project Topic Due Oct 23 Python for Tabular Data: Numerical Analysis Assignment 4 Due Oct 30 Python for Multidimensional Data: Xarray Assignment 5 Due Nov 6 Making Maps: Cartopy Assignment 6 Due Nov 13 Environmental Sciences Packages: GeoPandas, Re-gridding tools Assignment 7 Due Nov 20 Reproducible Research: Python Packaging, Binder, OpenDAP Assignment 8 Due Nov 27 Big Data: Parallel Computing, Dask No Assignment Dec 4 Big Data: Cloud Computing Final Project Part I Due Dec 11 No Class Final Project Part II Due"},{"location":"Syllabus/","title":"Syllabus","text":""},{"location":"Syllabus/#part-1-course-information","title":"Part 1: Course Information","text":"<p>Class Time: Monday, 2 to 5 PM  Location: ENR 323</p>"},{"location":"Syllabus/#instructor","title":"Instructor:","text":"<p>Xiaomeng Jin Department of Environmental Sciences Office: ENR 230 Email: xiaomeng.jin@rutgers.edu Office Hour: Friday, 1 \u2013 2 PM</p>"},{"location":"Syllabus/#part-2-overview","title":"Part 2: Overview","text":"<p>This course will introduce modern computing software, programming tools and best practices for open-source research that are transparent, accessible, reproducible and inclusive. The course consists of three components:   (1) Introduction to programming in the open-source Python language and in-depth exploration of the numerical analysis and visualization packages that comprise the modern scientific Python ecosystem;  (2) Introduction to the concept of open science and best practices for conducting open-source research;   (3) Introduction to cloud and parallel computing for big data analysis. The course is designed to be accessible for graduate students in atmospheric science, environmental sciences or other disciplines in earth sciences.  Student learning will be facilitated through a combination of lectures, in-class exercises, homework assignments and class projects.</p>"},{"location":"Syllabus/#part-3-course-structure","title":"Part 3: Course Structure","text":"<p>Format: The instructor will present new materials in the first half of the lecture. The second half of the class will be flipped: students will work first in small groups and then individually on assignments.  Textbook: There is no required textbook. All materials will come from free online resources and the course website itself.  Computers: Students can either bring their laptops or use the computers in ENR 323. Students will use Amarel, the university\u2019s high performance computing cluster, to work on their assignments and final project.  </p>"},{"location":"Syllabus/#part-4-grading-policy","title":"Part 4: Grading Policy","text":""},{"location":"Syllabus/#weekly-assignments-70","title":"Weekly Assignments (70%)","text":"<p>\u2022   Total: 100 \u2022   All questions complete: 50 \u2022   All questions correct: 30  \u2022   Clean, elegant, efficient code: rate between 0 and 10  \u2022   Clear comments and explanations: rate between 0 and 10  \u2022   Late penalty: -20 per day (24 hrs) \u2022   Lowest grade on an assignment will be dropped. </p>"},{"location":"Syllabus/#final-project-30","title":"Final Project (30%)","text":"<p> Part I: Individual Project (20%)  The goal of the final project is to assess your ability to combine and apply the skills you have learned in class in the context of a real-world research problem. Our class has mostly focused on tools for data analysis and visualization, so this must be the focus of your final project. Specifically, we seek to assess your ability to do the following tasks:  \u2022   Discover and download real datasets in standard formats (e.g. CSV, netCDF)  \u2022   Load the data into pandas or xarray, performing any necessary data cleanup (dealing with missing values, proper time encoding, etc.) along the way.  \u2022   Perform realistic scientific calculation involving, for example tasks such as grouping, aggregating, and applying mathematical formulas.  \u2022   Visualize your results in well-formatted plots. </p> <p> Part II: Reproducing Another Student\u2019s Project (10%)   The goal of the second part is to assess the reproducibility of the student\u2019s project, and whether the students can reproduce and collaborate with others on code development. Our class focuses on conducting open-source research that are transparent, accessible, reproducible and inclusive, so your final project should demonstrate your understanding and ability to perform open-source research. We seek to assess your ability to:  \u2022   Clearly document your analysis to make it reproducible.  \u2022   Reproduce the other student\u2019s final project.  \u2022   Bonus points will be given if the students submit pull requests and issues for code development. </p>"},{"location":"intro_to_python/","title":"Core Python Language","text":"In\u00a0[1]: Copied! <pre># comments are anything that comes after the \"#\" symbol\na = 1       # assign 1 to variable a\nb = \"hello\" # assign \"hello\" to variable b\n</pre> # comments are anything that comes after the \"#\" symbol a = 1       # assign 1 to variable a b = \"hello\" # assign \"hello\" to variable b <p>The following identifiers are used as reserved words, or keywords of the language, and cannot be used as ordinary identifiers. They must be spelled exactly as written here:</p> <pre><code>False      class      finally    is         return\nNone       continue   for        lambda     try\nTrue       def        from       nonlocal   while\nand        del        global     not        with\nas         elif       if         or         yield\nassert     else       import     pass\nbreak      except     in         raise</code></pre> <p>Additionally, the following a built in functions which are always available in your namespace once you open a python interpreter</p> <pre><code>abs() dict() help() min() setattr() all() dir() hex() next() slice() any()\ndivmod() id() object() sorted() ascii() enumerate() input() oct() staticmethod()\nbin() eval() int() open() str() bool() exec() isinstance() ord() sum() bytearray()\nfilter() issubclass() pow() super() bytes() float() iter() print() tuple()\ncallable() format() len() property() type() chr() frozenset() list() range()\nvars() classmethod() getattr() locals() repr() zip() compile() globals() map()\nreversed() __import__() complex() hasattr() max() round() delattr() hash()\nmemoryview() set()</code></pre> In\u00a0[2]: Copied! <pre># how to we see our variables?\nprint(a)\nprint(b)\nprint(a,b)\n</pre> # how to we see our variables? print(a) print(b) print(a,b) <pre>1\nhello\n1 hello\n</pre> <p>All variables are objects. Every object has a type (class). To find out what type your variables are</p> In\u00a0[3]: Copied! <pre>print(type(a))\nprint(type(b))\n</pre> print(type(a)) print(type(b)) <pre>&lt;class 'int'&gt;\n&lt;class 'str'&gt;\n</pre> In\u00a0[4]: Copied! <pre># as a shortcut, iPython notebooks will automatically print whatever is on the last line\ntype(b)\n</pre> # as a shortcut, iPython notebooks will automatically print whatever is on the last line type(b) Out[4]: <pre>str</pre> In\u00a0[5]: Copied! <pre># we can check for the type of an object\nprint(type(a) is int)\nprint(type(a) is str)\n</pre> # we can check for the type of an object print(type(a) is int) print(type(a) is str) <pre>True\nFalse\n</pre> <p>Different objects attributes and methods, which can be accessed via the syntax <code>variable.method</code></p> <p>IPython will autocomplete if you press <code>&lt;tab&gt;</code> to show you the methods available.</p> In\u00a0[6]: Copied! <pre># this returns the method itself\nb.capitalize\n</pre> # this returns the method itself b.capitalize Out[6]: <pre>&lt;function str.capitalize()&gt;</pre> In\u00a0[7]: Copied! <pre># this calls the method\nb.capitalize()\n# there are lots of other methods\n</pre> # this calls the method b.capitalize() # there are lots of other methods Out[7]: <pre>'Hello'</pre> In\u00a0[8]: Copied! <pre># binary operations act differently on different types of objects\nc = 'World'\nprint(b + c)\nprint(a + 2)\nprint(a + b)\n</pre> # binary operations act differently on different types of objects c = 'World' print(b + c) print(a + 2) print(a + b) <pre>helloWorld\n3\n</pre> <pre>\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[8], line 5\n      3 print(b + c)\n      4 print(a + 2)\n----&gt; 5 print(a + b)\n\nTypeError: unsupported operand type(s) for +: 'int' and 'str'</pre> In\u00a0[9]: Copied! <pre># addition / subtraction\n1+1-5\n</pre> # addition / subtraction 1+1-5 Out[9]: <pre>-3</pre> In\u00a0[10]: Copied! <pre># multiplication\n5 * 10\n</pre> # multiplication 5 * 10 Out[10]: <pre>50</pre> In\u00a0[11]: Copied! <pre># division\n1/2\n</pre> # division 1/2 Out[11]: <pre>0.5</pre> In\u00a0[12]: Copied! <pre># that was automatically converted to a float\ntype(1/2)\n</pre> # that was automatically converted to a float type(1/2) Out[12]: <pre>float</pre> In\u00a0[13]: Copied! <pre># exponentiation\n2**4\n</pre> # exponentiation 2**4 Out[13]: <pre>16</pre> In\u00a0[14]: Copied! <pre># rounding\nround(9/10)\n</pre> # rounding round(9/10) Out[14]: <pre>1</pre> In\u00a0[15]: Copied! <pre># built in complex number support\n(1+2j) / (3-4j)\n</pre> # built in complex number support (1+2j) / (3-4j) Out[15]: <pre>(-0.2+0.4j)</pre> In\u00a0[16]: Copied! <pre># logic\nTrue and True\n</pre> # logic True and True Out[16]: <pre>True</pre> In\u00a0[17]: Copied! <pre>True and False\n</pre> True and False Out[17]: <pre>False</pre> In\u00a0[18]: Copied! <pre>True or True\n</pre> True or True Out[18]: <pre>True</pre> In\u00a0[19]: Copied! <pre>(not True) or (not False)\n</pre> (not True) or (not False) Out[19]: <pre>True</pre> In\u00a0[20]: Copied! <pre>x = 100\nif x &gt; 0:\n    print('Positive Number')\nelif x &lt; 0:\n    print('Negative Number')\nelse:\n    print ('Zero!')\n</pre> x = 100 if x &gt; 0:     print('Positive Number') elif x &lt; 0:     print('Negative Number') else:     print ('Zero!') <pre>Positive Number\n</pre> In\u00a0[21]: Copied! <pre># indentation is MANDATORY\n# blocks are closed by indentation level\nif x &gt; 0:\n    print('Positive Number')\n    if x &gt;= 100:\n        print('Huge number!')\n</pre> # indentation is MANDATORY # blocks are closed by indentation level if x &gt; 0:     print('Positive Number')     if x &gt;= 100:         print('Huge number!') <pre>Positive Number\nHuge number!\n</pre> In\u00a0[22]: Copied! <pre># make a loop \ncount = 0\nwhile count &lt; 10:\n    # bad way\n    # count = count + 1\n    # better way\n    count += 1\nprint(count)\n</pre> # make a loop  count = 0 while count &lt; 10:     # bad way     # count = count + 1     # better way     count += 1 print(count) <pre>10\n</pre> In\u00a0[23]: Copied! <pre># use range\nfor i in range(5):\n    print(i)\n</pre> # use range for i in range(5):     print(i) <pre>0\n1\n2\n3\n4\n</pre> <p>Important point: in python, we always count from 0!</p> In\u00a0[24]: Copied! <pre># what is range?\ntype(range)\n</pre> # what is range? type(range) Out[24]: <pre>type</pre> In\u00a0[25]: Copied! <pre>range?\n</pre> range? <pre>Init signature: range(self, /, *args, **kwargs)\nDocstring:     \nrange(stop) -&gt; range object\nrange(start, stop[, step]) -&gt; range object\n\nReturn an object that produces a sequence of integers from start (inclusive)\nto stop (exclusive) by step.  range(i, j) produces i, i+1, i+2, ..., j-1.\nstart defaults to 0, and stop is omitted!  range(4) produces 0, 1, 2, 3.\nThese are exactly the valid indices for a list of 4 elements.\nWhen step is given, it specifies the increment (or decrement).\nType:           type\nSubclasses:     </pre> In\u00a0[26]: Copied! <pre># iterate over a list we make up\nfor pet in ['dog', 'cat', 'fish']:\n    print(pet, len(pet))\n</pre> # iterate over a list we make up for pet in ['dog', 'cat', 'fish']:     print(pet, len(pet)) <pre>dog 3\ncat 3\nfish 4\n</pre> <p>What is the thing in brackets? A list! Lists are one of the core python data structures.</p> In\u00a0[27]: Copied! <pre>l = ['dog', 'cat', 'fish']\ntype(l)\n</pre> l = ['dog', 'cat', 'fish'] type(l) Out[27]: <pre>list</pre> In\u00a0[28]: Copied! <pre># list have lots of methods\nl.sort()\nl\n</pre> # list have lots of methods l.sort() l Out[28]: <pre>['cat', 'dog', 'fish']</pre> In\u00a0[29]: Copied! <pre># we can convert a range to a list\nr = list(range(5))\nr\n</pre> # we can convert a range to a list r = list(range(5)) r Out[29]: <pre>[0, 1, 2, 3, 4]</pre> In\u00a0[30]: Copied! <pre>while r:\n    p = r.pop()\n    print('p:', p)\n    print('r:', r)\n</pre> while r:     p = r.pop()     print('p:', p)     print('r:', r) <pre>p: 4\nr: [0, 1, 2, 3]\np: 3\nr: [0, 1, 2]\np: 2\nr: [0, 1]\np: 1\nr: [0]\np: 0\nr: []\n</pre> <p>There are many different ways to interact with lists. Exploring them is part of the fun of python.</p> <p>list.append(x) Add an item to the end of the list. Equivalent to a[len(a):] = [x].</p> <p>list.extend(L) Extend the list by appending all the items in the given list. Equivalent to a[len(a):] = L.</p> <p>list.insert(i, x) Insert an item at a given position. The first argument is the index of the element before which to insert, so a.insert(0, x) inserts at the front of the list, and a.insert(len(a), x) is equivalent to a.append(x).</p> <p>list.remove(x) Remove the first item from the list whose value is x. It is an error if there is no such item.</p> <p>list.pop([i]) Remove the item at the given position in the list, and return it. If no index is specified, a.pop() removes and returns the last item in the list. (The square brackets around the i in the method signature denote that the parameter is optional, not that you should type square brackets at that position. You will see this notation frequently in the Python Library Reference.)</p> <p>list.clear() Remove all items from the list. Equivalent to del a[:].</p> <p>list.index(x) Return the index in the list of the first item whose value is x. It is an error if there is no such item.</p> <p>list.count(x) Return the number of times x appears in the list.</p> <p>list.sort() Sort the items of the list in place.</p> <p>list.reverse() Reverse the elements of the list in place.</p> <p>list.copy() Return a shallow copy of the list. Equivalent to a[:].</p> <p>Don't assume you know how list operations work!</p> In\u00a0[31]: Copied! <pre># \"add\" two lists\nx = list(range(5))\ny = list(range(10,15))\nz = x + y\nz\n</pre> # \"add\" two lists x = list(range(5)) y = list(range(10,15)) z = x + y z Out[31]: <pre>[0, 1, 2, 3, 4, 10, 11, 12, 13, 14]</pre> In\u00a0[32]: Copied! <pre># access items from a list\nprint('first', z[0])\nprint('last', z[-1])\nprint('first 3', z[:3])\nprint('last 3', z[-3:])\nprint('middle, skipping every other item', z[5:10:2])\n</pre> # access items from a list print('first', z[0]) print('last', z[-1]) print('first 3', z[:3]) print('last 3', z[-3:]) print('middle, skipping every other item', z[5:10:2]) <pre>first 0\nlast 14\nfirst 3 [0, 1, 2]\nlast 3 [12, 13, 14]\nmiddle, skipping every other item [10, 12, 14]\n</pre> <p>MEMORIZE THIS SYNTAX! It is central to so much of python and often proves confusing for users coming from other languages.</p> <p>In terms of set notation, python indexing is left inclusive, right exclusive. If you remember this, you will never go wrong.</p> In\u00a0[33]: Copied! <pre># that means we get an error from the following\nN = len(z)\nz[N]\n</pre> # that means we get an error from the following N = len(z) z[N] <pre>\n---------------------------------------------------------------------------\nIndexError                                Traceback (most recent call last)\nCell In[33], line 3\n      1 # that means we get an error from the following\n      2 N = len(z)\n----&gt; 3 z[N]\n\nIndexError: list index out of range</pre> In\u00a0[37]: Copied! <pre># this index notation also applies to strings\nname = 'Xiaomeng Jin'\nprint(name[:4])\n</pre> # this index notation also applies to strings name = 'Xiaomeng Jin' print(name[:4]) <pre>Xiao\n</pre> In\u00a0[38]: Copied! <pre>print(name[:-4])\n</pre> print(name[:-4]) <pre>Xiaomeng\n</pre> In\u00a0[39]: Copied! <pre>print(name[-4:])\n</pre> print(name[-4:]) <pre> Jin\n</pre> In\u00a0[40]: Copied! <pre># you can also test for the presence of items in a list\n5 in z\n</pre> # you can also test for the presence of items in a list 5 in z Out[40]: <pre>False</pre> <p>Lists are not meant for math! They don't have a datatype.</p> In\u00a0[41]: Copied! <pre>z[4] = 'fish'\nz\n</pre> z[4] = 'fish' z Out[41]: <pre>[0, 1, 2, 3, 'fish', 10, 11, 12, 13, 14]</pre> <p>Python is full of tricks for iterating and working with lists</p> In\u00a0[42]: Copied! <pre># a cool python trick: list comprehension\nsquares = [n**2 for n in range(5)]\nsquares\n</pre> # a cool python trick: list comprehension squares = [n**2 for n in range(5)] squares Out[42]: <pre>[0, 1, 4, 9, 16]</pre> In\u00a0[43]: Copied! <pre># iterate over two lists together uzing zip\nfor item1, item2 in zip(x,y):\n    print('first:', item1, 'second:', item2)\n</pre> # iterate over two lists together uzing zip for item1, item2 in zip(x,y):     print('first:', item1, 'second:', item2) <pre>first: 0 second: 10\nfirst: 1 second: 11\nfirst: 2 second: 12\nfirst: 3 second: 13\nfirst: 4 second: 14\n</pre> In\u00a0[48]: Copied! <pre># tuples are created with parentheses, or just commas\na = ('Jin', 32, True)\nb = 'Wang', 25, False\ntype(b)\n</pre> # tuples are created with parentheses, or just commas a = ('Jin', 32, True) b = 'Wang', 25, False type(b) Out[48]: <pre>tuple</pre> In\u00a0[50]: Copied! <pre># can be indexed like arrays\nprint(a[1]) # not the first element!\n</pre> # can be indexed like arrays print(a[1]) # not the first element! <pre>32\n</pre> In\u00a0[51]: Copied! <pre># and they can be unpacked\nname, age, status = a\n</pre> # and they can be unpacked name, age, status = a In\u00a0[52]: Copied! <pre># different ways to create dictionaries\nd = {'name': 'Jin', 'age': 32}\ne = dict(name='Wang', age=25)\ne\n</pre> # different ways to create dictionaries d = {'name': 'Jin', 'age': 32} e = dict(name='Wang', age=25) e Out[52]: <pre>{'name': 'Wang', 'age': 25}</pre> In\u00a0[53]: Copied! <pre># access a value\nd['name']\n</pre> # access a value d['name'] Out[53]: <pre>'Jin'</pre> <p>Square brackets <code>[...]</code> are python for \"get item\" in many different contexts.</p> In\u00a0[54]: Copied! <pre># test for the presence of a key\nprint('age' in d)\nprint('height' in e)\n</pre> # test for the presence of a key print('age' in d) print('height' in e) <pre>True\nFalse\n</pre> In\u00a0[55]: Copied! <pre># try to access a non-existant key\nd['height']\n</pre> # try to access a non-existant key d['height'] <pre>\n---------------------------------------------------------------------------\nKeyError                                  Traceback (most recent call last)\nCell In[55], line 2\n      1 # try to access a non-existant key\n----&gt; 2 d['height']\n\nKeyError: 'height'</pre> In\u00a0[56]: Copied! <pre># add a new key\nd['height'] = (5,3) # a tuple\nd\n</pre> # add a new key d['height'] = (5,3) # a tuple d Out[56]: <pre>{'name': 'Jin', 'age': 32, 'height': (5, 3)}</pre> In\u00a0[60]: Copied! <pre># keys don't have to be strings\nd[99] = 'nighty nine'\nd\n</pre> # keys don't have to be strings d[99] = 'nighty nine' d Out[60]: <pre>{'name': 'Jin', 'age': 32, 'height': (5, 3), 99: 'nighty nine'}</pre> In\u00a0[61]: Copied! <pre># iterate over keys\nfor k in d:\n    print(k, d[k])\n</pre> # iterate over keys for k in d:     print(k, d[k]) <pre>name Jin\nage 32\nheight (5, 3)\n99 nighty nine\n</pre> In\u00a0[62]: Copied! <pre># better way\n### python 2\n### for key, val in d.iteritems()\nfor key, val in d.items():\n    print(key, val)\n</pre> # better way ### python 2 ### for key, val in d.iteritems() for key, val in d.items():     print(key, val) <pre>name Jin\nage 32\nheight (5, 3)\n99 nighty nine\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"intro_to_python/#core-python-language","title":"Core Python Language\u00b6","text":"<p>Mostly copied from the official python tutorial</p>"},{"location":"intro_to_python/#invoking-python","title":"Invoking Python\u00b6","text":"<p>There are three main ways to use python.</p> <ol> <li>By running a python file, e.g. <code>python myscript.py</code></li> <li>Through an interactive console (python interpreter or ipython shell)</li> <li>In an interactive iPython notebook</li> </ol> <p>We will be using the iPython notebook.</p>"},{"location":"intro_to_python/#python-versions","title":"Python Versions\u00b6","text":"<p>There are two versions of the python language out there: python 2 and python 3. Python 2 is more common in the wild but is depracated. The community is moving to python 3. As new python learners, you should learn python 3. But it is important to be aware that python 2 exists. It is possible that a package you want to use is only supported in python 2. In general, it is pretty easy to switch between then.</p> <p>Some of the main changes in python 3 are:</p> <ul> <li><code>print</code> is a function</li> <li>Integer division returns a float</li> <li>Iterators behave differently</li> <li>Unicode is used for encoding code</li> </ul>"},{"location":"intro_to_python/#basic-variables-numbers-and-string","title":"Basic Variables: Numbers and String\u00b6","text":""},{"location":"intro_to_python/#math","title":"Math\u00b6","text":"<p>Basic arithmetic and boolean logic is part of the core python library.</p>"},{"location":"intro_to_python/#conditionals","title":"Conditionals\u00b6","text":"<p>The first step to programming. Plus an intro to python syntax.</p>"},{"location":"intro_to_python/#more-flow-control","title":"More Flow Control\u00b6","text":""},{"location":"intro_to_python/#lists","title":"Lists\u00b6","text":""},{"location":"intro_to_python/#other-data-structures","title":"Other Data Structures\u00b6","text":"<p>We are almost there. We have the building blocks we need to do basic programming. But python has some other data structures we need to learn about.</p>"},{"location":"intro_to_python/#tuples","title":"Tuples\u00b6","text":"<p>Tuples are similar to lists, but they are immutable\u2014they can't be extended or modified. What is the point of this? Generally speaking: to pack together inhomogeneous data. Tuples can then be unpacked and distributed by other parts of your code.</p> <p>Tuples may seem confusing at first, but with time you will come to appreciate them.</p>"},{"location":"intro_to_python/#dictionaries","title":"Dictionaries\u00b6","text":"<p>This is an extremely useful data structure. It maps keys to values.</p> <p>Dictionaries are unordered!</p>"},{"location":"lecture_1_intro/","title":"Lecture 1 Introduction","text":""},{"location":"lecture_1_intro/#presentation-slides-are-posted-on-canvas","title":"Presentation slides are posted on Canvas","text":""},{"location":"lecture_1_intro/#key-points","title":"Key Points","text":"<ol> <li>What is computational research?</li> <li>Data analysis pipeline for computational research. </li> <li>Challenges in research computing: Complexity, Reproducibility, Data Size. </li> <li>Topics we will cover in class.  </li> <li>Class logistics. </li> </ol>"},{"location":"lecture_1_intro/#topics-we-will-cover-in-class","title":"Topics we will cover in class","text":"<ol> <li>Python Programming</li> <li>Open-source Computing</li> <li>Big Data</li> </ol>"},{"location":"lecture_1_intro/#learning-goals","title":"Learning Goals","text":"<ol> <li>Be able to construct complete, well-structured programs in Python.</li> <li>Read and write most common atmospheric and environmental sciences data formats.</li> <li>Perform basic exploratory data analysis.</li> <li>Use visualization to enhance interpretation of environmental science data, including making maps and interactive visualizations.</li> <li>Practice open-source research through version control, packaging etc.</li> <li>Practice big-data analysis with parallel computing.</li> <li>Understand the concepts of cloud computing. </li> </ol>"}]}